// Generated by CoffeeScript 1.7.1
(function() {
  var assert, coeff, expect, id_3_by_3, inverted, invertible, matrix, matrix_example, matrix_example_10, matrix_for_reduction, matrix_for_reduction2, matrix_reduced, matrix_reduced2, matrix_reduced3, mult_result, other, trans, x, y, _ref;

  _ref = require("chai"), expect = _ref.expect, assert = _ref.assert;

  require("../src/core.js");

  matrix = [[1, 2, 3], [4, 5, 6]];

  trans = [[1, 4], [2, 5], [3, 6]];

  other = [[0, 0], [1, 1], [2, 2]];

  mult_result = [[8, 8], [17, 17]];

  id_3_by_3 = [[1, 0, 0], [0, 1, 0], [0, 0, 1]];

  matrix_example = [[3, 2], [2, 1]];

  matrix_example_10 = [[1346269, 832040], [832040, 514229]];

  matrix_for_reduction = [[1, 3, -1], [0, 1, 7]];

  matrix_reduced = [[1, 0, -22], [0, 1, 7]];

  matrix_for_reduction2 = [[1, 2, -1, -4], [2, 3, -1, -11], [-2, 0, -3, 22]];

  matrix_reduced2 = [[1, 0, 0, -8], [0, 1, 0, 1], [0, 0, 1, -2]];

  matrix_reduced3 = [[1, 0, 0, -8], [0, 1, 0, 1], [0, 0, 1, -2]];

  invertible = [[1, 0, 10], [0, 1, 5], [0, 0, 5]];

  inverted = [[1, 0, -2], [0, 1, -1], [0, 0, 0.2]];

  describe("S.Matrix", function() {
    it(".transpose() should return transposed Matrix", function() {
      var m, m2;
      m = new S.Matrix(matrix);
      m2 = m.transposed();
      return expect(m2.mtx).to.deep.equal(trans);
    });
    it(".mult(other) throws error for incompatible", function() {
      var f, m, m2;
      m = new S.Matrix(trans);
      m2 = new S.Matrix(other);
      f = function() {
        var m3;
        return m3 = m.mult(m2);
      };
      return expect(f).to["throw"]("error: incompatible");
    });
    it(".mult(other) returns the correct result", function() {
      var m, m2, m3;
      m = new S.Matrix(matrix);
      m2 = new S.Matrix(other);
      m3 = m.mult(m2);
      return expect(m3.mtx).to.deep.equal(mult_result);
    });
    it(".exp(n) throws error for non-square", function() {
      var f, m;
      m = new S.Matrix(trans);
      f = function() {
        return m.exp(10);
      };
      return expect(f).to["throw"]("error: incompatible");
    });
    it(".exp(10) gives correct answer", function() {
      var m, m2;
      m = new S.Matrix(matrix_example);
      m2 = m.exp(10);
      return expect(m2.mtx).to.be.deep.equal(matrix_example_10);
    });
    it(".pow(n) returns the correct values", function() {
      var m, m2;
      m = new S.Matrix([[1, 2, 3], [4, 5, 6]]);
      m2 = m.pow(2);
      return expect(m2.mtx).to.be.deep.equal([[1, 4, 9], [16, 25, 36]]);
    });
    it(".toReducedRowEchelonForm makes correct matrix 1", function() {
      var m;
      m = new S.Matrix(matrix_for_reduction);
      m.toReducedRowEchelonForm();
      return expect(m.mtx).to.be.deep.equal(matrix_reduced);
    });
    it(".toReducedRowEchelonForm makes correct matrix 2", function() {
      var i, j, m, _i, _ref1, _results;
      m = new S.Matrix(matrix_for_reduction2);
      m.toReducedRowEchelonForm();
      _results = [];
      for (i = _i = 0, _ref1 = m.height - 1; 0 <= _ref1 ? _i <= _ref1 : _i >= _ref1; i = 0 <= _ref1 ? ++_i : --_i) {
        _results.push((function() {
          var _j, _ref2, _results1;
          _results1 = [];
          for (j = _j = 0, _ref2 = m.width - 1; 0 <= _ref2 ? _j <= _ref2 : _j >= _ref2; j = 0 <= _ref2 ? ++_j : --_j) {
            _results1.push(assert(m.mtx[i][j] === matrix_reduced2[i][j]));
          }
          return _results1;
        })());
      }
      return _results;
    });
    it(".invert() throws error for non-square", function() {
      var f, m;
      m = new S.Matrix(matrix);
      f = function() {
        return m.inverse();
      };
      return expect(f).to["throw"]("error: no inverse for non-square matrix");
    });
    it(".inverse() returns correct value", function() {
      var m, m2;
      m = new S.Matrix(invertible);
      m2 = m.inverse();
      return expect(m2.mtx).to.be.deep.equal(inverted);
    });
    return it(".subtract(other) returns correct value", function() {
      var m, m2;
      m = new S.Matrix([[1, 2, 4]]);
      m2 = new S.Matrix([[0, 2, 3]]);
      return expect(m.subtract(m2).mtx).to.be.deep.equal([[1, 0, 1]]);
    });
  });

  y = [52.21, 53.12, 54.48, 55.84, 57.20, 58.57, 59.93, 61.29, 63.11, 64.47, 66.28, 68.10, 69.92, 72.19, 74.46];

  x = new S.Matrix([1.47, 1.50, 1.52, 1.55, 1.57, 1.60, 1.63, 1.65, 1.68, 1.70, 1.73, 1.75, 1.78, 1.80, 1.83].map(function(v) {
    return [Math.pow(v, 0), Math.pow(v, 1), Math.pow(v, 2)];
  }));

  coeff = new S.ColumnVector([128.8128035798277, -143.1620228653037, 61.960325442985436]);

  describe("S.ColumnVector", function() {
    it(".regression_coefficients() are correct", function() {
      var coefficients, errors, outcome, _ref1;
      outcome = new S.ColumnVector(y);
      _ref1 = outcome.regression_coefficients(x), coefficients = _ref1[0], errors = _ref1[1];
      expect(coefficients.mtx).to.be.deep.equal(coeff.mtx);
      return expect(outcome.mtx).to.be.deep.equal(x.mult(coeff).add(errors).mtx);
    });
    return it(".regression_coefficients() are correct simple", function() {
      var coefficients, e, errors, outcome, _ref1;
      outcome = new S.ColumnVector([50, 60, 70, 80, 90, 100]);
      x = new S.Matrix([[1, 50], [1, 60], [1, 70], [1, 80], [1, 90], [1, 100]]);
      _ref1 = outcome.regression_coefficients(x), coefficients = _ref1[0], errors = _ref1[1];
      e = 0.00000001;
      expect(coefficients.mtx[0][0]).to.be.closeTo(0, e);
      return expect(coefficients.mtx[1][0]).to.be.closeTo(1, e);
    });
  });

  describe("S.IdentityMatrix", function() {
    return it("constructor produces correct matrix", function() {
      var m;
      m = new S.IdentityMatrix(3);
      return expect(m.mtx).to.be.deep.equal(id_3_by_3);
    });
  });

}).call(this);
