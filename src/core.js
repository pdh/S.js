// Generated by CoffeeScript 1.7.1
(function() {
  var ColumnVector, IdentityMatrix, Matrix,
    __hasProp = {}.hasOwnProperty,
    __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; };

  global.S = {};

  Matrix = (function() {
    function Matrix(mtx) {
      this.mtx = mtx;
      this.height = this.mtx.length;
      this.width = this.mtx[0].length;
    }

    Matrix.prototype.transposed = function() {
      var i, j, trans, _i, _j, _ref, _ref1;
      trans = [];
      for (i = _i = 0, _ref = this.width - 1; 0 <= _ref ? _i <= _ref : _i >= _ref; i = 0 <= _ref ? ++_i : --_i) {
        trans[i] = [];
        for (j = _j = 0, _ref1 = this.height - 1; 0 <= _ref1 ? _j <= _ref1 : _j >= _ref1; j = 0 <= _ref1 ? ++_j : --_j) {
          trans[i][j] = this.mtx[j][i];
        }
      }
      return new Matrix(trans);
    };

    Matrix.prototype.mult = function(other) {
      var c, k, r, result, sum, _i, _j, _k, _ref, _ref1, _ref2;
      if (this.width !== other.height) {
        throw "error: incompatible";
      }
      result = [];
      for (r = _i = 0, _ref = this.height - 1; 0 <= _ref ? _i <= _ref : _i >= _ref; r = 0 <= _ref ? ++_i : --_i) {
        result[r] = [];
        for (c = _j = 0, _ref1 = other.width - 1; 0 <= _ref1 ? _j <= _ref1 : _j >= _ref1; c = 0 <= _ref1 ? ++_j : --_j) {
          sum = 0;
          for (k = _k = 0, _ref2 = this.width - 1; 0 <= _ref2 ? _k <= _ref2 : _k >= _ref2; k = 0 <= _ref2 ? ++_k : --_k) {
            sum += this.mtx[r][k] * other.mtx[k][c];
          }
          result[r][c] = sum;
        }
      }
      return new Matrix(result);
    };

    Matrix.prototype.exp = function(n) {
      var i, result, _i;
      if (this.width !== this.height) {
        throw "error: incompatible";
      }
      result = new IdentityMatrix(this.height);
      for (i = _i = 1; 1 <= n ? _i <= n : _i >= n; i = 1 <= n ? ++_i : --_i) {
        result = result.mult(this);
      }
      return result;
    };

    Matrix.prototype.pow = function(n) {
      var i, j, res, _i, _j, _ref, _ref1;
      res = [];
      for (i = _i = 0, _ref = this.height - 1; 0 <= _ref ? _i <= _ref : _i >= _ref; i = 0 <= _ref ? ++_i : --_i) {
        res[i] = [];
        for (j = _j = 0, _ref1 = this.width - 1; 0 <= _ref1 ? _j <= _ref1 : _j >= _ref1; j = 0 <= _ref1 ? ++_j : --_j) {
          res[i][j] = Math.pow(this.mtx[i][j], n);
        }
      }
      return new Matrix(res);
    };

    Matrix.prototype.toReducedRowEchelonForm = function() {
      var i, j, lead, r, tmp, val, _i, _j, _k, _l, _ref, _ref1, _ref2, _ref3;
      lead = 0;
      for (r = _i = 0, _ref = this.height - 1; 0 <= _ref ? _i <= _ref : _i >= _ref; r = 0 <= _ref ? ++_i : --_i) {
        if (this.width <= lead) {
          return;
        }
        i = r;
        while (this.mtx[i][lead] === 0) {
          i += 1;
          if (i === this.height) {
            i = r;
            lead += 1;
            if (lead === this.width) {
              return;
            }
          }
        }
        tmp = this.mtx[i];
        this.mtx[i] = this.mtx[r];
        this.mtx[r] = tmp;
        val = this.mtx[r][lead];
        for (j = _j = 0, _ref1 = this.width - 1; 0 <= _ref1 ? _j <= _ref1 : _j >= _ref1; j = 0 <= _ref1 ? ++_j : --_j) {
          this.mtx[r][j] /= val;
        }
        for (i = _k = 0, _ref2 = this.height - 1; 0 <= _ref2 ? _k <= _ref2 : _k >= _ref2; i = 0 <= _ref2 ? ++_k : --_k) {
          if (i === r) {
            continue;
          }
          val = this.mtx[i][lead];
          for (j = _l = 0, _ref3 = this.width - 1; 0 <= _ref3 ? _l <= _ref3 : _l >= _ref3; j = 0 <= _ref3 ? ++_l : --_l) {
            this.mtx[i][j] -= val * this.mtx[r][j];
          }
        }
        lead += 1;
      }
      return this;
    };

    Matrix.prototype.inverse = function() {
      var res;
      res = new Matrix(this.mtx);
      res.invert();
      return res;
    };

    Matrix.prototype.invert = function() {
      var I, i, _i, _j, _ref, _ref1;
      if (this.width !== this.height) {
        throw "error: no inverse for non-square matrix";
      }
      I = new IdentityMatrix(this.height);
      for (i = _i = 0, _ref = this.height - 1; 0 <= _ref ? _i <= _ref : _i >= _ref; i = 0 <= _ref ? ++_i : --_i) {
        this.mtx[i] = this.mtx[i].concat(I.mtx[i]);
      }
      this.width *= 2;
      this.toReducedRowEchelonForm();
      for (i = _j = 0, _ref1 = this.height - 1; 0 <= _ref1 ? _j <= _ref1 : _j >= _ref1; i = 0 <= _ref1 ? ++_j : --_j) {
        this.mtx[i].splice(0, this.height);
      }
      this.width /= 2;
      return this;
    };

    Matrix.prototype.subtract = function(other) {
      var i, j, res, _i, _j, _ref, _ref1;
      if ((this.width !== other.width) || (this.height !== other.height)) {
        throw "error: incompatible";
      }
      res = [];
      for (i = _i = 0, _ref = this.height - 1; 0 <= _ref ? _i <= _ref : _i >= _ref; i = 0 <= _ref ? ++_i : --_i) {
        res[i] = [];
        for (j = _j = 0, _ref1 = this.width - 1; 0 <= _ref1 ? _j <= _ref1 : _j >= _ref1; j = 0 <= _ref1 ? ++_j : --_j) {
          res[i][j] = this.mtx[i][j] - other.mtx[i][j];
        }
      }
      return new Matrix(res);
    };

    Matrix.prototype.add = function(other) {
      var i, j, res, _i, _j, _ref, _ref1;
      if ((this.width !== other.width) || (this.height !== other.height)) {
        throw "error: incompatible";
      }
      res = [];
      for (i = _i = 0, _ref = this.height - 1; 0 <= _ref ? _i <= _ref : _i >= _ref; i = 0 <= _ref ? ++_i : --_i) {
        res[i] = [];
        for (j = _j = 0, _ref1 = this.width - 1; 0 <= _ref1 ? _j <= _ref1 : _j >= _ref1; j = 0 <= _ref1 ? ++_j : --_j) {
          res[i][j] = this.mtx[i][j] + other.mtx[i][j];
        }
      }
      return new Matrix(res);
    };

    return Matrix;

  })();

  ColumnVector = (function(_super) {
    __extends(ColumnVector, _super);

    function ColumnVector(array) {
      ColumnVector.__super__.constructor.call(this, array.map(function(v) {
        return [v];
      }));
    }

    ColumnVector.prototype.regression_coefficients = function(X) {
      var B, XB, X_t, e;
      X_t = X.transposed();
      B = X_t.mult(X).inverse().mult(X_t).mult(this);
      XB = X.mult(B);
      e = this.subtract(XB);
      return [B, e];
    };

    return ColumnVector;

  })(Matrix);

  IdentityMatrix = (function(_super) {
    __extends(IdentityMatrix, _super);

    function IdentityMatrix(n) {
      var i, j, _i, _j, _ref, _ref1;
      this.height = n;
      this.width = n;
      this.mtx = [];
      for (i = _i = 0, _ref = n - 1; 0 <= _ref ? _i <= _ref : _i >= _ref; i = 0 <= _ref ? ++_i : --_i) {
        this.mtx[i] = [];
        for (j = _j = 0, _ref1 = n - 1; 0 <= _ref1 ? _j <= _ref1 : _j >= _ref1; j = 0 <= _ref1 ? ++_j : --_j) {
          this.mtx[i][j] = i === j ? 1 : 0;
        }
      }
    }

    return IdentityMatrix;

  })(Matrix);

  S.Matrix = Matrix;

  S.ColumnVector = ColumnVector;

  S.IdentityMatrix = IdentityMatrix;

}).call(this);
